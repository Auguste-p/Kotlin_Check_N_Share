<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FIX_AUTH_EMAIL_FINAL.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_AUTH_EMAIL_FINAL.md" />
              <option name="updatedContent" value="# ✅ Fix Final : Authentification par Email&#10;&#10;## Date : 8 décembre 2025&#10;&#10;##  Problème résolu&#10;&#10;**Problème** : &#10;1. Le formulaire de login demande un **email** mais le code cherchait par **username**&#10;2. Même avec les bons identifiants, l'authentification échouait avec &quot;identifiants incorrects&quot;&#10;&#10;##  Modifications apportées&#10;&#10;### 1. **LocalDatabaseHelper.kt**&#10;✅ Ajout d'une nouvelle fonction `authenticateUserByEmail(email, password)`&#10;- Cherche l'utilisateur par email au lieu de username&#10;- Logs détaillés pour déboguer&#10;- Compare les hashs de mots de passe&#10;&#10;### 2. **DatabaseHelper.kt**&#10;✅ Ajout du wrapper pour `authenticateUserByEmail()`&#10;```kotlin&#10;fun authenticateUserByEmail(email: String, password: String): User? {&#10;    return localHelper.authenticateUserByEmail(email, password)&#10;}&#10;```&#10;&#10;### 3. **LoginActivity.kt**&#10;✅ Modification pour utiliser `authenticateUserByEmail()` au lieu de `authenticateUser()`&#10;✅ Message d'erreur corrigé : &quot;Email ou mot de passe incorrect&quot;&#10;&#10;### 4. **Build vérifié**&#10;```&#10;BUILD SUCCESSFUL in 8s&#10;✅ Aucune erreur de compilation&#10;```&#10;&#10;##  Comment tester MAINTENANT&#10;&#10;### Étape 1️⃣ : Désinstaller l'ancienne version&#10;**Dans Android Studio** : Run → Run 'app'&#10;&#10;Cela va automatiquement :&#10;- Désinstaller l'ancienne version&#10;- Installer la nouvelle avec authentification par email&#10;- Créer la base de données version 3&#10;&#10;### Étape 2️⃣ : Tester avec le compte par défaut&#10;Après installation, un compte de test est créé automatiquement :&#10;- **Email** : `test@example.com`&#10;- **Password** : `test123`&#10;&#10;**Action** : Se connecter avec ces identifiants → ✅ devrait fonctionner&#10;&#10;### Étape 3️⃣ : Créer un nouveau compte&#10;1. Cliquer sur &quot;S'inscrire&quot;&#10;2. Remplir :&#10;   - Username : `myuser` (n'importe quel nom)&#10;   - Email : `myuser@test.com` ← **IMPORTANT : retenir cet email**&#10;   - Password : `password123`&#10;   - Confirmer : `password123`&#10;3. Cliquer sur &quot;S'inscrire&quot;&#10;4. Message : &quot;Compte créé avec succès !&quot;&#10;&#10;### Étape 4️⃣ : Se connecter avec le nouveau compte&#10;1. Sur la page de login&#10;2. **Email** : `myuser@test.com` ← **Utiliser l'EMAIL, pas le username !**&#10;3. **Password** : `password123`&#10;4. Cliquer sur &quot;Se connecter&quot;&#10;5. ✅ **Devrait fonctionner !**&#10;&#10;## ⚠️ Point important&#10;&#10;### Le formulaire demande un EMAIL&#10;&#10;Le champ affiché est &quot;Email&quot; :&#10;- ✅ Utiliser : `test@example.com`&#10;- ❌ Ne PAS utiliser : `test` (username)&#10;&#10;### À la création du compte&#10;&#10;Vous devez fournir :&#10;- Username : pour identifier l'utilisateur dans l'app&#10;- **Email : pour la connexion** ← C'est celui-ci qui sert à se connecter&#10;- Password&#10;&#10;### À la connexion&#10;&#10;Vous devez utiliser :&#10;- **Email** (PAS le username)&#10;- Password&#10;&#10;##  Vérifier les logs (si problème)&#10;&#10;### Ouvrir Logcat&#10;1. Onglet **Logcat** en bas d'Android Studio&#10;2. Filtrer : `LocalDatabaseHelper`&#10;3. Niveau : **Debug**&#10;&#10;### À la CRÉATION d'un compte :&#10;```&#10;D/LocalDatabaseHelper: createUser: Creating user: myuser with email: myuser@test.com&#10;D/LocalDatabaseHelper: createUser: Hashed password: &lt;hash&gt;&#10;D/LocalDatabaseHelper: createUser: User created successfully with ID: 2&#10;```&#10;&#10;### À la CONNEXION (avec EMAIL) :&#10;```&#10;D/LocalDatabaseHelper: authenticateUserByEmail: Attempting to authenticate user with email: myuser@test.com&#10;D/LocalDatabaseHelper: authenticateUserByEmail: Hashed password: &lt;hash&gt;&#10;D/LocalDatabaseHelper: authenticateUserByEmail: User found. Stored password hash: &lt;hash&gt;&#10;D/LocalDatabaseHelper: authenticateUserByEmail: Password match: true ← DOIT ÊTRE TRUE&#10;D/LocalDatabaseHelper: authenticateUserByEmail: Authentication successful for email: myuser@test.com&#10;```&#10;&#10;### ⚠️ Si vous voyez `Password match: false`&#10;Les hashs ne correspondent pas. Vérifiez :&#10;1. Que vous utilisez exactement le même mot de passe&#10;2. Pas d'espaces avant/après le mot de passe&#10;3. Les logs du hash créé vs hash testé&#10;&#10;##  Tableau récapitulatif&#10;&#10;| Action | Champ à utiliser | Valeur exemple |&#10;|--------|------------------|----------------|&#10;| **Inscription** | Username | `myuser` |&#10;|  | Email | `myuser@test.com` |&#10;|  | Password | `password123` |&#10;| **Connexion** | **Email** ⚠️ | `myuser@test.com` |&#10;|  | Password | `password123` |&#10;&#10;## ✨ Résultat attendu&#10;&#10;Après ces étapes :&#10;- ✅ Connexion avec `test@example.com` / `test123` fonctionne&#10;- ✅ Création de nouveaux comptes fonctionne&#10;- ✅ Connexion avec l'**email** du nouveau compte fonctionne&#10;- ✅ Les logs montrent `Password match: true`&#10;- ✅ Message &quot;Bienvenue [username]!&quot; s'affiche&#10;- ✅ Redirection vers la page d'accueil&#10;&#10;##  Si ça ne marche toujours pas&#10;&#10;1. **Vérifier que vous utilisez l'EMAIL** (pas le username) pour vous connecter&#10;2. **Ouvrir Logcat** et chercher les messages de `LocalDatabaseHelper`&#10;3. **Vérifier** que `Password match: true` apparaît dans les logs&#10;4. **Prendre une capture** des logs et me les envoyer si le problème persiste&#10;&#10;---&#10;&#10;##  Prêt à tester !&#10;&#10;Lancez l'app maintenant et connectez-vous avec :&#10;- **Email** : `test@example.com`&#10;- **Password** : `test123`&#10;&#10;Ça devrait fonctionner ! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/checknshare/LoginActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/checknshare/LoginActivity.kt" />
              <option name="originalContent" value="package com.example.checknshare&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.example.checknshare.database.DatabaseHelper&#10;import com.example.checknshare.databinding.ActivityLoginBinding&#10;&#10;class LoginActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityLoginBinding&#10;    private lateinit var dbHelper: DatabaseHelper&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityLoginBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // Initialiser la base de données Supabase&#10;        dbHelper = DatabaseHelper(this)&#10;&#10;        // Cacher l'ActionBar pour une meilleure présentation&#10;        supportActionBar?.hide()&#10;&#10;        // Bouton de connexion&#10;        binding.btnLogin.setOnClickListener {&#10;            val email = binding.etUsername.text.toString().trim()&#10;            val password = binding.etPassword.text.toString().trim()&#10;&#10;            if (validateInput(email, password)) {&#10;                loginUser(email, password)&#10;            }&#10;        }&#10;&#10;        // Lien vers l'inscription&#10;        binding.tvSignup.setOnClickListener {&#10;            val intent = Intent(this, SignupActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;    }&#10;&#10;&#10;    private fun validateInput(email: String, password: String): Boolean {&#10;        return when {&#10;            email.isEmpty() -&gt; {&#10;                binding.etUsername.error = &quot;Email requis&quot;&#10;                false&#10;            }&#10;            !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches() -&gt; {&#10;                binding.etUsername.error = &quot;Email invalide&quot;&#10;                false&#10;            }&#10;            password.isEmpty() -&gt; {&#10;                binding.etPassword.error = &quot;Mot de passe requis&quot;&#10;                false&#10;            }&#10;            password.length &lt; 6 -&gt; {&#10;                binding.etPassword.error = &quot;Le mot de passe doit contenir au moins 6 caractères&quot;&#10;                false&#10;            }&#10;            else -&gt; true&#10;        }&#10;    }&#10;&#10;    private fun loginUser(email: String, password: String) {&#10;        // Désactiver le bouton pendant le chargement&#10;        binding.btnLogin.isEnabled = false&#10;        binding.btnLogin.text = &quot;Connexion en cours...&quot;&#10;&#10;        try {&#10;            val user = dbHelper.authenticateUser(email, password)&#10;&#10;            if (user != null) {&#10;                // Connexion réussie&#10;                Toast.makeText(&#10;                    this,&#10;                    &quot;Bienvenue ${user.username} !&quot;,&#10;                    Toast.LENGTH_SHORT&#10;                ).show()&#10;&#10;                // Sauvegarder la session (SharedPreferences)&#10;                saveUserSession(user.id, user.username, user.email)&#10;&#10;                // Naviguer vers MainActivity&#10;                val intent = Intent(this, MainActivity::class.java)&#10;                startActivity(intent)&#10;                finish() // Fermer LoginActivity&#10;            } else {&#10;                // Échec de connexion&#10;                Toast.makeText(&#10;                    this,&#10;                    &quot;Nom d'utilisateur ou mot de passe incorrect&quot;,&#10;                    Toast.LENGTH_SHORT&#10;                ).show()&#10;                binding.btnLogin.isEnabled = true&#10;                binding.btnLogin.text = &quot;Se connecter&quot;&#10;            }&#10;        } catch (e: Exception) {&#10;            Toast.makeText(&#10;                this,&#10;                &quot;Erreur de connexion: ${e.message}&quot;,&#10;                Toast.LENGTH_LONG&#10;            ).show()&#10;            binding.btnLogin.isEnabled = true&#10;            binding.btnLogin.text = &quot;Se connecter&quot;&#10;        }&#10;    }&#10;&#10;    private fun saveUserSession(userId: Int, username: String, email: String) {&#10;        val sharedPreferences = getSharedPreferences(&quot;UserSession&quot;, MODE_PRIVATE)&#10;        val editor = sharedPreferences.edit()&#10;        editor.putInt(&quot;userId&quot;, userId)&#10;        editor.putString(&quot;username&quot;, username)&#10;        editor.putString(&quot;email&quot;, email)&#10;        editor.putBoolean(&quot;isLoggedIn&quot;, true)&#10;        editor.apply()&#10;    }&#10;&#10;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.checknshare&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.example.checknshare.database.DatabaseHelper&#10;import com.example.checknshare.databinding.ActivityLoginBinding&#10;&#10;class LoginActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityLoginBinding&#10;    private lateinit var dbHelper: DatabaseHelper&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        binding = ActivityLoginBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // Initialiser la base de données Supabase&#10;        dbHelper = DatabaseHelper(this)&#10;&#10;        // Cacher l'ActionBar pour une meilleure présentation&#10;        supportActionBar?.hide()&#10;&#10;        // Bouton de connexion&#10;        binding.btnLogin.setOnClickListener {&#10;            val email = binding.etUsername.text.toString().trim()&#10;            val password = binding.etPassword.text.toString().trim()&#10;&#10;            if (validateInput(email, password)) {&#10;                loginUser(email, password)&#10;            }&#10;        }&#10;&#10;        // Lien vers l'inscription&#10;        binding.tvSignup.setOnClickListener {&#10;            val intent = Intent(this, SignupActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;    }&#10;&#10;&#10;    private fun validateInput(email: String, password: String): Boolean {&#10;        return when {&#10;            email.isEmpty() -&gt; {&#10;                binding.etUsername.error = &quot;Email requis&quot;&#10;                false&#10;            }&#10;            !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches() -&gt; {&#10;                binding.etUsername.error = &quot;Email invalide&quot;&#10;                false&#10;            }&#10;            password.isEmpty() -&gt; {&#10;                binding.etPassword.error = &quot;Mot de passe requis&quot;&#10;                false&#10;            }&#10;            password.length &lt; 6 -&gt; {&#10;                binding.etPassword.error = &quot;Le mot de passe doit contenir au moins 6 caractères&quot;&#10;                false&#10;            }&#10;            else -&gt; true&#10;        }&#10;    }&#10;&#10;    private fun loginUser(email: String, password: String) {&#10;        // Désactiver le bouton pendant le chargement&#10;        binding.btnLogin.isEnabled = false&#10;        binding.btnLogin.text = &quot;Connexion en cours...&quot;&#10;&#10;        try {&#10;            val user = dbHelper.authenticateUserByEmail(email, password)&#10;&#10;            if (user != null) {&#10;                // Connexion réussie&#10;                Toast.makeText(&#10;                    this,&#10;                    &quot;Bienvenue ${user.username} !&quot;,&#10;                    Toast.LENGTH_SHORT&#10;                ).show()&#10;&#10;                // Sauvegarder la session (SharedPreferences)&#10;                saveUserSession(user.id, user.username, user.email)&#10;&#10;                // Naviguer vers MainActivity&#10;                val intent = Intent(this, MainActivity::class.java)&#10;                startActivity(intent)&#10;                finish() // Fermer LoginActivity&#10;            } else {&#10;                // Échec de connexion&#10;                Toast.makeText(&#10;                    this,&#10;                    &quot;Email ou mot de passe incorrect&quot;,&#10;                    Toast.LENGTH_SHORT&#10;                ).show()&#10;                binding.btnLogin.isEnabled = true&#10;                binding.btnLogin.text = &quot;Se connecter&quot;&#10;            }&#10;        } catch (e: Exception) {&#10;            Toast.makeText(&#10;                this,&#10;                &quot;Erreur de connexion: ${e.message}&quot;,&#10;                Toast.LENGTH_LONG&#10;            ).show()&#10;            binding.btnLogin.isEnabled = true&#10;            binding.btnLogin.text = &quot;Se connecter&quot;&#10;        }&#10;    }&#10;&#10;    private fun saveUserSession(userId: Int, username: String, email: String) {&#10;        val sharedPreferences = getSharedPreferences(&quot;UserSession&quot;, MODE_PRIVATE)&#10;        val editor = sharedPreferences.edit()&#10;        editor.putInt(&quot;userId&quot;, userId)&#10;        editor.putString(&quot;username&quot;, username)&#10;        editor.putString(&quot;email&quot;, email)&#10;        editor.putBoolean(&quot;isLoggedIn&quot;, true)&#10;        editor.apply()&#10;    }&#10;&#10;&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/checknshare/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/checknshare/MainActivity.kt" />
              <option name="originalContent" value="package com.example.checknshare&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.Menu&#10;import android.view.MenuItem&#10;import com.google.android.material.bottomnavigation.BottomNavigationView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.AppBarConfiguration&#10;import androidx.navigation.ui.setupActionBarWithNavController&#10;import androidx.navigation.ui.setupWithNavController&#10;import com.example.checknshare.databinding.ActivityMainBinding&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Vérifier si l'utilisateur est connecté&#10;        if (!isUserLoggedIn()) {&#10;            redirectToLogin()&#10;            return&#10;        }&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        val navView: BottomNavigationView = binding.navView&#10;&#10;        val navController = findNavController(R.id.nav_host_fragment_activity_main)&#10;        // Passing each menu ID as a set of Ids because each&#10;        // menu should be considered as top level destinations.&#10;        val appBarConfiguration = AppBarConfiguration(&#10;            setOf(&#10;                R.id.navigation_home, R.id.navigation_map, R.id.navigation_notifications, R.id.navigation_profile&#10;            )&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;&#10;        // Désactiver la mise à jour automatique du titre par la navigation&#10;        navController.addOnDestinationChangedListener { _, _, _ -&gt;&#10;            supportActionBar?.title = &quot;Check'N'Share&quot;&#10;        }&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu?): Boolean {&#10;        menuInflater.inflate(R.menu.main_menu, menu)&#10;        return true&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_logout -&gt; {&#10;                logout()&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun isUserLoggedIn(): Boolean {&#10;        val sharedPreferences = getSharedPreferences(&quot;UserSession&quot;, MODE_PRIVATE)&#10;        return sharedPreferences.getBoolean(&quot;isLoggedIn&quot;, false)&#10;    }&#10;&#10;    private fun redirectToLogin() {&#10;        val intent = Intent(this, LoginActivity::class.java)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    private fun logout() {&#10;        // Effacer la session&#10;        val sharedPreferences = getSharedPreferences(&quot;UserSession&quot;, MODE_PRIVATE)&#10;        val editor = sharedPreferences.edit()&#10;        editor.clear()&#10;        editor.apply()&#10;&#10;        // Retourner à l'écran de connexion&#10;        redirectToLogin()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.checknshare&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.Menu&#10;import android.view.MenuItem&#10;import com.google.android.material.bottomnavigation.BottomNavigationView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.navigation.findNavController&#10;import androidx.navigation.ui.AppBarConfiguration&#10;import androidx.navigation.ui.setupActionBarWithNavController&#10;import androidx.navigation.ui.setupWithNavController&#10;import com.example.checknshare.databinding.ActivityMainBinding&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityMainBinding&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Vérifier si l'utilisateur est connecté&#10;        if (!isUserLoggedIn()) {&#10;            redirectToLogin()&#10;            return&#10;        }&#10;&#10;        binding = ActivityMainBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        val navView: BottomNavigationView = binding.navView&#10;&#10;        val navController = findNavController(R.id.nav_host_fragment_activity_main)&#10;        // Passing each menu ID as a set of Ids because each&#10;        // menu should be considered as top level destinations.&#10;        val appBarConfiguration = AppBarConfiguration(&#10;            setOf(&#10;                R.id.navigation_home, R.id.navigation_map, R.id.navigation_notifications, R.id.navigation_profile&#10;            )&#10;        )&#10;        setupActionBarWithNavController(navController, appBarConfiguration)&#10;        navView.setupWithNavController(navController)&#10;&#10;        // Désactiver la mise à jour automatique du titre par la navigation&#10;        navController.addOnDestinationChangedListener { _, _, _ -&gt;&#10;            supportActionBar?.title = &quot;Check'N'Share&quot;&#10;        }&#10;    }&#10;&#10;    override fun onCreateOptionsMenu(menu: Menu?): Boolean {&#10;        menuInflater.inflate(R.menu.main_menu, menu)&#10;        return true&#10;    }&#10;&#10;    override fun onOptionsItemSelected(item: MenuItem): Boolean {&#10;        return when (item.itemId) {&#10;            R.id.action_logout -&gt; {&#10;                logout()&#10;                true&#10;            }&#10;            else -&gt; super.onOptionsItemSelected(item)&#10;        }&#10;    }&#10;&#10;    private fun isUserLoggedIn(): Boolean {&#10;        val sharedPreferences = getSharedPreferences(&quot;UserSession&quot;, MODE_PRIVATE)&#10;        return sharedPreferences.getBoolean(&quot;isLoggedIn&quot;, false)&#10;    }&#10;&#10;    private fun redirectToLogin() {&#10;        val intent = Intent(this, LoginActivity::class.java)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    private fun logout() {&#10;        // Effacer la session&#10;        val sharedPreferences = getSharedPreferences(&quot;UserSession&quot;, MODE_PRIVATE)&#10;        val editor = sharedPreferences.edit()&#10;        editor.clear()&#10;        editor.apply()&#10;&#10;        // Retourner à l'écran de connexion&#10;        redirectToLogin()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/checknshare/database/DatabaseHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/checknshare/database/DatabaseHelper.kt" />
              <option name="originalContent" value="package com.example.checknshare.database&#10;&#10;import android.content.Context&#10;import com.example.checknshare.models.Post&#10;import com.example.checknshare.ui.notifications.Notification as UINotification&#10;&#10;/**&#10; * Wrapper pour LocalDatabaseHelper (SQLite)&#10; * Permet d'avoir une interface cohérente pour toutes les opérations de base de données&#10; */&#10;class DatabaseHelper(context: Context) {&#10;&#10;    private val localHelper = LocalDatabaseHelper(context)&#10;&#10;    // ========== Users ==========&#10;&#10;    fun authenticateUser(username: String, password: String): User? {&#10;        return localHelper.authenticateUser(username, password)&#10;    }&#10;&#10;    fun createUser(username: String, email: String, password: String): Boolean {&#10;        return localHelper.createUser(username, email, password)&#10;    }&#10;&#10;    fun createUserReturnId(username: String, email: String, password: String): Long {&#10;        return localHelper.createUserReturnId(username, email, password)&#10;    }&#10;&#10;    fun userExists(username: String): Boolean {&#10;        return localHelper.userExists(username)&#10;    }&#10;&#10;    fun getAnyUserId(): Int {&#10;        return localHelper.getAnyUserId()&#10;    }&#10;&#10;    // ========== Posts ==========&#10;&#10;    fun getAllPosts(): List&lt;Post&gt; {&#10;        return localHelper.getAllPosts()&#10;    }&#10;&#10;    fun createPost(userId: Int, imageName: String?, location: String?): Long {&#10;        return localHelper.createPost(userId, imageName, location)&#10;    }&#10;&#10;    fun deletePost(postId: Int): Int {&#10;        return localHelper.deletePost(postId)&#10;    }&#10;&#10;    // ========== Likes ==========&#10;&#10;    fun getLikeCount(postId: Int): Int {&#10;        return localHelper.getLikeCount(postId)&#10;    }&#10;&#10;    fun hasUserLiked(postId: Int, userId: Int): Boolean {&#10;        return localHelper.hasUserLiked(postId, userId)&#10;    }&#10;&#10;    fun addLike(postId: Int, userId: Int): Long {&#10;        return localHelper.addLike(postId, userId)&#10;    }&#10;&#10;    fun removeLike(postId: Int, userId: Int): Int {&#10;        return localHelper.removeLike(postId, userId)&#10;    }&#10;&#10;    fun toggleLike(postId: Int, userId: Int): Boolean {&#10;        return localHelper.toggleLike(postId, userId)&#10;    }&#10;&#10;    // ========== Notifications ==========&#10;&#10;    fun getAllNotifications(recipientUserId: Int? = null): List&lt;UINotification&gt; {&#10;        return localHelper.getAllNotifications(recipientUserId)&#10;    }&#10;&#10;    fun createNotification(&#10;        recipientUserId: Int,&#10;        actorName: String,&#10;        actionText: String,&#10;        location: String?,&#10;        profileImageUrl: String?&#10;    ): Long {&#10;        return localHelper.createNotification(recipientUserId, actorName, actionText, location, profileImageUrl)&#10;    }&#10;&#10;    fun markNotificationAsRead(notificationId: Int): Int {&#10;        return localHelper.markNotificationAsRead(notificationId)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.checknshare.database&#10;&#10;import android.content.Context&#10;import com.example.checknshare.models.Post&#10;import com.example.checknshare.ui.notifications.Notification as UINotification&#10;&#10;/**&#10; * Wrapper pour LocalDatabaseHelper (SQLite)&#10; * Permet d'avoir une interface cohérente pour toutes les opérations de base de données&#10; */&#10;class DatabaseHelper(context: Context) {&#10;&#10;    private val localHelper = LocalDatabaseHelper(context)&#10;&#10;    // ========== Users ==========&#10;&#10;    fun authenticateUser(username: String, password: String): User? {&#10;        return localHelper.authenticateUser(username, password)&#10;    }&#10;&#10;    fun authenticateUserByEmail(email: String, password: String): User? {&#10;        return localHelper.authenticateUserByEmail(email, password)&#10;    }&#10;&#10;    fun createUser(username: String, email: String, password: String): Boolean {&#10;        return localHelper.createUser(username, email, password)&#10;    }&#10;&#10;    fun createUserReturnId(username: String, email: String, password: String): Long {&#10;        return localHelper.createUserReturnId(username, email, password)&#10;    }&#10;&#10;    fun userExists(username: String): Boolean {&#10;        return localHelper.userExists(username)&#10;    }&#10;&#10;    fun getAnyUserId(): Int {&#10;        return localHelper.getAnyUserId()&#10;    }&#10;&#10;    // ========== Posts ==========&#10;&#10;    fun getAllPosts(): List&lt;Post&gt; {&#10;        return localHelper.getAllPosts()&#10;    }&#10;&#10;    fun createPost(userId: Int, imageName: String?, location: String?): Long {&#10;        return localHelper.createPost(userId, imageName, location)&#10;    }&#10;&#10;    fun deletePost(postId: Int): Int {&#10;        return localHelper.deletePost(postId)&#10;    }&#10;&#10;    // ========== Likes ==========&#10;&#10;    fun getLikeCount(postId: Int): Int {&#10;        return localHelper.getLikeCount(postId)&#10;    }&#10;&#10;    fun hasUserLiked(postId: Int, userId: Int): Boolean {&#10;        return localHelper.hasUserLiked(postId, userId)&#10;    }&#10;&#10;    fun addLike(postId: Int, userId: Int): Long {&#10;        return localHelper.addLike(postId, userId)&#10;    }&#10;&#10;    fun removeLike(postId: Int, userId: Int): Int {&#10;        return localHelper.removeLike(postId, userId)&#10;    }&#10;&#10;    fun toggleLike(postId: Int, userId: Int): Boolean {&#10;        return localHelper.toggleLike(postId, userId)&#10;    }&#10;&#10;    // ========== Notifications ==========&#10;&#10;    fun getAllNotifications(recipientUserId: Int? = null): List&lt;UINotification&gt; {&#10;        return localHelper.getAllNotifications(recipientUserId)&#10;    }&#10;&#10;    fun createNotification(&#10;        recipientUserId: Int,&#10;        actorName: String,&#10;        actionText: String,&#10;        location: String?,&#10;        profileImageUrl: String?&#10;    ): Long {&#10;        return localHelper.createNotification(recipientUserId, actorName, actionText, location, profileImageUrl)&#10;    }&#10;&#10;    fun markNotificationAsRead(notificationId: Int): Int {&#10;        return localHelper.markNotificationAsRead(notificationId)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/checknshare/database/LocalDatabaseHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/checknshare/database/LocalDatabaseHelper.kt" />
              <option name="originalContent" value="package com.example.checknshare.database&#10;&#10;import android.content.ContentValues&#10;import android.content.Context&#10;import android.database.sqlite.SQLiteDatabase&#10;import android.database.sqlite.SQLiteOpenHelper&#10;import android.util.Log&#10;import com.example.checknshare.models.Post&#10;import com.example.checknshare.ui.notifications.Notification as UINotification&#10;import java.security.MessageDigest&#10;import java.time.LocalDateTime&#10;import java.time.format.DateTimeFormatter&#10;&#10;class LocalDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;LocalDatabaseHelper&quot;&#10;        private const val DATABASE_NAME = &quot;checknshare.db&quot;&#10;        // Version bumpée pour forcer onUpgrade et recréation de la DB avec les bons hashs&#10;        private const val DATABASE_VERSION = 3&#10;&#10;        // Users&#10;        private const val TABLE_USERS = &quot;users&quot;&#10;        private const val COLUMN_ID = &quot;id&quot;&#10;        private const val COLUMN_USERNAME = &quot;username&quot;&#10;        private const val COLUMN_EMAIL = &quot;email&quot;&#10;        private const val COLUMN_PASSWORD = &quot;password&quot;&#10;        private const val COLUMN_CREATED_AT = &quot;created_at&quot;&#10;&#10;        // Posts&#10;        private const val TABLE_POSTS = &quot;posts&quot;&#10;        private const val COLUMN_POST_ID = &quot;id&quot;&#10;        private const val COLUMN_POST_USER_ID = &quot;userId&quot;&#10;        private const val COLUMN_POST_IMAGE = &quot;imageName&quot;&#10;        private const val COLUMN_POST_LOCATION = &quot;location&quot;&#10;        private const val COLUMN_POST_LOCATION_ADDRESS = &quot;location_address&quot;&#10;        private const val COLUMN_POST_CREATED_AT = &quot;created_at&quot;&#10;&#10;        // Likes&#10;        private const val TABLE_LIKES = &quot;likes&quot;&#10;        private const val COLUMN_LIKE_ID = &quot;id&quot;&#10;        private const val COLUMN_LIKE_POST_ID = &quot;post_id&quot;&#10;        private const val COLUMN_LIKE_USER_ID = &quot;user_id&quot;&#10;&#10;        // Notifications&#10;        private const val TABLE_NOTIFICATIONS = &quot;notifications&quot;&#10;        private const val COLUMN_NOTIFICATION_ID = &quot;id&quot;&#10;        private const val COLUMN_NOTIFICATION_RECIPIENT = &quot;recipient_user_id&quot;&#10;        private const val COLUMN_NOTIFICATION_ACTOR = &quot;actor_name&quot;&#10;        private const val COLUMN_NOTIFICATION_ACTION = &quot;action_text&quot;&#10;        private const val COLUMN_NOTIFICATION_LOCATION = &quot;location&quot;&#10;        private const val COLUMN_NOTIFICATION_TIMEAGO = &quot;time_ago&quot;&#10;        private const val COLUMN_NOTIFICATION_PROFILE = &quot;profile_image&quot;&#10;        private const val COLUMN_NOTIFICATION_IS_READ = &quot;is_read&quot;&#10;    }&#10;&#10;    override fun onCreate(db: SQLiteDatabase?) {&#10;        Log.d(TAG, &quot;onCreate: creating tables if not exists&quot;)&#10;        // Users table&#10;        val createUsers = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_USERS (&#10;                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_USERNAME TEXT UNIQUE NOT NULL,&#10;                $COLUMN_EMAIL TEXT UNIQUE NOT NULL,&#10;                $COLUMN_PASSWORD TEXT NOT NULL,&#10;                $COLUMN_CREATED_AT TEXT DEFAULT CURRENT_TIMESTAMP&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        // Posts table&#10;        val createPosts = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_POSTS (&#10;                $COLUMN_POST_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_POST_USER_ID INTEGER NOT NULL,&#10;                $COLUMN_POST_IMAGE TEXT,&#10;                $COLUMN_POST_LOCATION TEXT,&#10;                $COLUMN_POST_LOCATION_ADDRESS TEXT,&#10;                $COLUMN_POST_CREATED_AT TEXT DEFAULT CURRENT_TIMESTAMP,&#10;                FOREIGN KEY($COLUMN_POST_USER_ID) REFERENCES $TABLE_USERS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        // Likes table&#10;        val createLikes = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_LIKES (&#10;                $COLUMN_LIKE_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_LIKE_POST_ID INTEGER NOT NULL,&#10;                $COLUMN_LIKE_USER_ID INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_LIKE_POST_ID) REFERENCES $TABLE_POSTS($COLUMN_POST_ID),&#10;                FOREIGN KEY($COLUMN_LIKE_USER_ID) REFERENCES $TABLE_USERS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        db?.execSQL(createUsers)&#10;        db?.execSQL(createPosts)&#10;        db?.execSQL(createLikes)&#10;&#10;        // Seed: créer un utilisateur de test&#10;        val hashedPassword = hashPassword(&quot;test123&quot;)&#10;        val userValues = ContentValues().apply {&#10;            put(COLUMN_USERNAME, &quot;test&quot;)&#10;            put(COLUMN_EMAIL, &quot;test@example.com&quot;)&#10;            put(COLUMN_PASSWORD, hashedPassword)&#10;        }&#10;        val userId = db?.insert(TABLE_USERS, null, userValues) ?: -1L&#10;&#10;        // Seed: quelques posts exemples (utiliser des drawables existants)&#10;        val sampleImages = listOf(&quot;photo_placeholder_1&quot;, &quot;photo_placeholder_2&quot;, &quot;photo_placeholder_3&quot;)&#10;        for (i in 0 until 3) {&#10;            val postValues = ContentValues().apply {&#10;                put(COLUMN_POST_USER_ID, userId.toInt())&#10;                put(COLUMN_POST_IMAGE, sampleImages[i % sampleImages.size])&#10;                put(COLUMN_POST_LOCATION, &quot;Paris, France&quot;)&#10;                put(COLUMN_POST_LOCATION_ADDRESS, &quot;Adresse Exemple $i&quot;)&#10;            }&#10;            val postId = db?.insert(TABLE_POSTS, null, postValues) ?: -1L&#10;&#10;            // Seed: ajouter quelques likes sur les posts&#10;            val likeCount = (i + 1) * 5&#10;            for (j in 0 until likeCount) {&#10;                val likeValues = ContentValues().apply {&#10;                    put(COLUMN_LIKE_POST_ID, postId.toInt())&#10;                    put(COLUMN_LIKE_USER_ID, userId.toInt())&#10;                }&#10;                db?.insert(TABLE_LIKES, null, likeValues)&#10;            }&#10;        }&#10;&#10;        // Notifications table (create and seed)&#10;        val createNotifications = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_NOTIFICATIONS (&#10;                $COLUMN_NOTIFICATION_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_NOTIFICATION_RECIPIENT INTEGER NOT NULL,&#10;                $COLUMN_NOTIFICATION_ACTOR TEXT,&#10;                $COLUMN_NOTIFICATION_ACTION TEXT,&#10;                $COLUMN_NOTIFICATION_LOCATION TEXT,&#10;                $COLUMN_NOTIFICATION_TIMEAGO TEXT,&#10;                $COLUMN_NOTIFICATION_PROFILE TEXT,&#10;                $COLUMN_NOTIFICATION_IS_READ INTEGER DEFAULT 0,&#10;                FOREIGN KEY($COLUMN_NOTIFICATION_RECIPIENT) REFERENCES $TABLE_USERS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        db?.execSQL(createNotifications)&#10;&#10;        // Seed: créer quelques notifications d'exemple pour l'utilisateur test&#10;        val sampleNotifications = listOf(&#10;            UINotification(1, &quot;Marie Dubois&quot;, &quot;a publié une photo&quot;, &quot;Tour Eiffel, Paris&quot;, &quot;5 min&quot;),&#10;            UINotification(2, &quot;Alex Martin&quot;, &quot;a publié une photo&quot;, &quot;Le Comptoir du Relais, Paris&quot;, &quot;1h&quot;),&#10;            UINotification(3, &quot;Sophie Bernard&quot;, &quot;a commenté votre photo&quot;, &quot;Musée du Louvre, Paris&quot;, &quot;2h&quot;),&#10;            UINotification(4, &quot;Thomas Laurent&quot;, &quot;a aimé votre photo&quot;, &quot;Arc de Triomphe, Paris&quot;, &quot;3h&quot;)&#10;        )&#10;&#10;        for (n in sampleNotifications) {&#10;            val notifValues = ContentValues().apply {&#10;                put(COLUMN_NOTIFICATION_RECIPIENT, userId.toInt())&#10;                put(COLUMN_NOTIFICATION_ACTOR, n.userName)&#10;                put(COLUMN_NOTIFICATION_ACTION, n.action)&#10;                put(COLUMN_NOTIFICATION_LOCATION, n.location)&#10;                put(COLUMN_NOTIFICATION_TIMEAGO, n.timeAgo)&#10;                put(COLUMN_NOTIFICATION_PROFILE, n.profileImageUrl)&#10;            }&#10;            db?.insert(TABLE_NOTIFICATIONS, null, notifValues)&#10;        }&#10;    }&#10;&#10;    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {&#10;        Log.d(TAG, &quot;onUpgrade: upgrading DB from $oldVersion to $newVersion - dropping and recreating tables (dev)&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_LIKES&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_POSTS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_USERS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NOTIFICATIONS&quot;)&#10;        onCreate(db)&#10;    }&#10;&#10;    override fun onOpen(db: SQLiteDatabase?) {&#10;        super.onOpen(db)&#10;        Log.d(TAG, &quot;onOpen: ensuring posts table exists&quot;)&#10;        // Create posts table if it's missing (safe no-op if already present)&#10;        val ensurePosts = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_POSTS (&#10;                $COLUMN_POST_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_POST_USER_ID INTEGER NOT NULL,&#10;                $COLUMN_POST_IMAGE TEXT,&#10;                $COLUMN_POST_LOCATION TEXT,&#10;                $COLUMN_POST_LOCATION_ADDRESS TEXT,&#10;                $COLUMN_POST_CREATED_AT TEXT DEFAULT CURRENT_TIMESTAMP,&#10;                FOREIGN KEY($COLUMN_POST_USER_ID) REFERENCES $TABLE_USERS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;        db?.execSQL(ensurePosts)&#10;    }&#10;&#10;    private fun hashPassword(password: String): String {&#10;        val bytes = MessageDigest.getInstance(&quot;SHA-256&quot;).digest(password.toByteArray())&#10;        return bytes.joinToString(&quot;&quot;) { &quot;%02x&quot;.format(it) }&#10;    }&#10;&#10;    // Authentifier un utilisateur&#10;    fun authenticateUser(username: String, password: String): User? {&#10;        val db = readableDatabase&#10;        val hashedPassword = hashPassword(password)&#10;&#10;        Log.d(TAG, &quot;authenticateUser: Attempting to authenticate user: $username&quot;)&#10;        Log.d(TAG, &quot;authenticateUser: Hashed password: $hashedPassword&quot;)&#10;&#10;        // D'abord vérifier si l'utilisateur existe&#10;        val userCheckCursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID, COLUMN_USERNAME, COLUMN_EMAIL, COLUMN_PASSWORD),&#10;            &quot;$COLUMN_USERNAME = ?&quot;,&#10;            arrayOf(username),&#10;            null, null, null&#10;        )&#10;&#10;        if (userCheckCursor.moveToFirst()) {&#10;            val storedPassword = userCheckCursor.getString(userCheckCursor.getColumnIndexOrThrow(COLUMN_PASSWORD))&#10;            Log.d(TAG, &quot;authenticateUser: User found. Stored password hash: $storedPassword&quot;)&#10;            Log.d(TAG, &quot;authenticateUser: Password match: ${storedPassword == hashedPassword}&quot;)&#10;            userCheckCursor.close()&#10;        } else {&#10;            Log.d(TAG, &quot;authenticateUser: User not found in database&quot;)&#10;            userCheckCursor.close()&#10;            return null&#10;        }&#10;&#10;        // Authentification avec mot de passe&#10;        val cursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID, COLUMN_USERNAME, COLUMN_EMAIL),&#10;            &quot;$COLUMN_USERNAME = ? AND $COLUMN_PASSWORD = ?&quot;,&#10;            arrayOf(username, hashedPassword),&#10;            null, null, null&#10;        )&#10;&#10;        return if (cursor.moveToFirst()) {&#10;            val user = User(&#10;                id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID)),&#10;                username = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_USERNAME)),&#10;                email = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_EMAIL))&#10;            )&#10;            cursor.close()&#10;            Log.d(TAG, &quot;authenticateUser: Authentication successful for user: $username&quot;)&#10;            user&#10;        } else {&#10;            cursor.close()&#10;            Log.d(TAG, &quot;authenticateUser: Authentication failed - password mismatch&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    // Créer un nouvel utilisateur (retourne true/false)&#10;    fun createUser(username: String, email: String, password: String): Boolean {&#10;        val db = writableDatabase&#10;        val hashedPassword = hashPassword(password)&#10;&#10;        Log.d(TAG, &quot;createUser: Creating user: $username with email: $email&quot;)&#10;        Log.d(TAG, &quot;createUser: Hashed password: $hashedPassword&quot;)&#10;&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_USERNAME, username)&#10;            put(COLUMN_EMAIL, email)&#10;            put(COLUMN_PASSWORD, hashedPassword)&#10;        }&#10;&#10;        return try {&#10;            val result = db.insert(TABLE_USERS, null, values)&#10;            if (result != -1L) {&#10;                Log.d(TAG, &quot;createUser: User created successfully with ID: $result&quot;)&#10;                true&#10;            } else {&#10;                Log.e(TAG, &quot;createUser: Failed to insert user&quot;)&#10;                false&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;createUser: Exception occurred: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Créer un nouvel utilisateur et retourner l'id inséré (ou -1 si erreur)&#10;    fun createUserReturnId(username: String, email: String, password: String): Long {&#10;        val db = writableDatabase&#10;        val hashedPassword = hashPassword(password)&#10;&#10;        Log.d(TAG, &quot;createUserReturnId: Creating user: $username with email: $email&quot;)&#10;        Log.d(TAG, &quot;createUserReturnId: Hashed password: $hashedPassword&quot;)&#10;&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_USERNAME, username)&#10;            put(COLUMN_EMAIL, email)&#10;            put(COLUMN_PASSWORD, hashedPassword)&#10;        }&#10;        return try {&#10;            val result = db.insert(TABLE_USERS, null, values)&#10;            Log.d(TAG, &quot;createUserReturnId: User created with ID: $result&quot;)&#10;            result&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;createUserReturnId: Exception occurred: ${e.message}&quot;, e)&#10;            -1L&#10;        }&#10;    }&#10;&#10;    // Vérifier si un utilisateur existe&#10;    fun userExists(username: String): Boolean {&#10;        val db = readableDatabase&#10;        val cursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID),&#10;            &quot;$COLUMN_USERNAME = ?&quot;,&#10;            arrayOf(username),&#10;            null, null, null&#10;        )&#10;&#10;        val exists = cursor.count &gt; 0&#10;        cursor.close()&#10;        return exists&#10;    }&#10;&#10;    // Récupérer tous les posts (avec username)&#10;    fun getAllPosts(): List&lt;Post&gt; {&#10;        val posts = mutableListOf&lt;Post&gt;()&#10;        val db = readableDatabase&#10;        val query = &quot;SELECT p.$COLUMN_POST_ID as id, p.$COLUMN_POST_USER_ID as user_id, u.$COLUMN_USERNAME as username, p.$COLUMN_POST_IMAGE as image_name, p.$COLUMN_POST_LOCATION as location, p.$COLUMN_POST_LOCATION as location_address, p.$COLUMN_POST_CREATED_AT as created_at FROM $TABLE_POSTS p JOIN $TABLE_USERS u ON p.$COLUMN_POST_USER_ID = u.$COLUMN_ID ORDER BY p.$COLUMN_POST_CREATED_AT DESC&quot;&#10;        val cursor = db.rawQuery(query, null)&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val post = Post(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;id&quot;)),&#10;                    userId = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;user_id&quot;)),&#10;                    username = cursor.getString(cursor.getColumnIndexOrThrow(&quot;username&quot;)),&#10;                    imageName = cursor.getString(cursor.getColumnIndexOrThrow(&quot;image_name&quot;)),&#10;                    location = cursor.getString(cursor.getColumnIndexOrThrow(&quot;location&quot;)),&#10;                    locationAddress = cursor.getString(cursor.getColumnIndexOrThrow(&quot;location_address&quot;)),&#10;                    createdAt = cursor.getString(cursor.getColumnIndexOrThrow(&quot;created_at&quot;))&#10;                )&#10;                posts.add(post)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        Log.d(TAG, &quot;getAllPosts: retrieved ${posts.size} posts&quot;);&#10;        return posts&#10;    }&#10;&#10;    // Obtenir le nombre de likes pour un post&#10;    fun getLikeCount(postId: Int): Int {&#10;        val db = readableDatabase&#10;        val cursor = db.query(&#10;            TABLE_LIKES,&#10;            arrayOf(&quot;COUNT(*) as cnt&quot;),&#10;            &quot;$COLUMN_LIKE_POST_ID = ?&quot;,&#10;            arrayOf(postId.toString()),&#10;            null, null, null&#10;        )&#10;        var count = 0&#10;        if (cursor.moveToFirst()) {&#10;            count = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;cnt&quot;))&#10;        }&#10;        cursor.close()&#10;        return count&#10;    }&#10;&#10;    // Créer un post&#10;    fun createPost(userId: Int, imageName: String?, location: String?): Long {&#10;        val db = writableDatabase&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;dd-MM-yyy HH:mm&quot;)&#10;        val currentDate = LocalDateTime.now().format(formatter)&#10;&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_POST_USER_ID, userId)&#10;            put(COLUMN_POST_IMAGE, imageName)&#10;            put(COLUMN_POST_LOCATION, location)&#10;            put(COLUMN_POST_LOCATION_ADDRESS, location)&#10;            put(COLUMN_POST_CREATED_AT, currentDate)&#10;        }&#10;        return db.insert(TABLE_POSTS, null, values)&#10;    }&#10;&#10;    // Supprimer un post (et ses likes associés en cascade grâce aux FK)&#10;    fun deletePost(postId: Int): Int {&#10;        val db = writableDatabase&#10;        // Supprimer d'abord les likes associés&#10;        db.delete(TABLE_LIKES, &quot;$COLUMN_LIKE_POST_ID = ?&quot;, arrayOf(postId.toString()))&#10;        // Puis supprimer le post&#10;        return db.delete(TABLE_POSTS, &quot;$COLUMN_POST_ID = ?&quot;, arrayOf(postId.toString()))&#10;    }&#10;&#10;    // Vérifier si un utilisateur a liké un post&#10;    fun hasUserLiked(postId: Int, userId: Int): Boolean {&#10;        val db = readableDatabase&#10;        val cursor = db.query(&#10;            TABLE_LIKES,&#10;            arrayOf(COLUMN_LIKE_ID),&#10;            &quot;$COLUMN_LIKE_POST_ID = ? AND $COLUMN_LIKE_USER_ID = ?&quot;,&#10;            arrayOf(postId.toString(), userId.toString()),&#10;            null, null, null&#10;        )&#10;        val liked = cursor.count &gt; 0&#10;        cursor.close()&#10;        return liked&#10;    }&#10;&#10;    // Ajouter un like&#10;    fun addLike(postId: Int, userId: Int): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_LIKE_POST_ID, postId)&#10;            put(COLUMN_LIKE_USER_ID, userId)&#10;        }&#10;        return db.insert(TABLE_LIKES, null, values)&#10;    }&#10;&#10;    // Retirer un like&#10;    fun removeLike(postId: Int, userId: Int): Int {&#10;        val db = writableDatabase&#10;        return db.delete(&#10;            TABLE_LIKES,&#10;            &quot;$COLUMN_LIKE_POST_ID = ? AND $COLUMN_LIKE_USER_ID = ?&quot;,&#10;            arrayOf(postId.toString(), userId.toString())&#10;        )&#10;    }&#10;&#10;    // Basculer like/unlike, retourne true si maintenant liké&#10;    fun toggleLike(postId: Int, userId: Int): Boolean {&#10;        if (hasUserLiked(postId, userId)) {&#10;            removeLike(postId, userId)&#10;            return false&#10;        }&#10;        addLike(postId, userId)&#10;        return true&#10;    }&#10;&#10;    // Obtenir un any user id existant (utile pour dev bypass)&#10;    fun getAnyUserId(): Int {&#10;        val db = readableDatabase&#10;        val cursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID),&#10;            null, null, null, null, &quot;$COLUMN_ID ASC&quot;,&#10;            &quot;1&quot;&#10;        )&#10;        var id = -1&#10;        if (cursor.moveToFirst()) {&#10;            id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID))&#10;        }&#10;        cursor.close()&#10;        return id&#10;    }&#10;&#10;    // Récupérer toutes les notifications pour un utilisateur (par défaut tous)&#10;    fun getAllNotifications(recipientUserId: Int? = null): List&lt;UINotification&gt; {&#10;        val notifications = mutableListOf&lt;UINotification&gt;()&#10;        val db = readableDatabase&#10;        val selection: String?&#10;        val selectionArgs: Array&lt;String&gt;?&#10;        if (recipientUserId != null) {&#10;            selection = &quot;$COLUMN_NOTIFICATION_RECIPIENT = ?&quot;&#10;            selectionArgs = arrayOf(recipientUserId.toString())&#10;        } else {&#10;            selection = null&#10;            selectionArgs = null&#10;        }&#10;&#10;        val cursor = db.query(&#10;            TABLE_NOTIFICATIONS,&#10;            arrayOf(&#10;                COLUMN_NOTIFICATION_ID,&#10;                COLUMN_NOTIFICATION_ACTOR,&#10;                COLUMN_NOTIFICATION_ACTION,&#10;                COLUMN_NOTIFICATION_LOCATION,&#10;                COLUMN_NOTIFICATION_TIMEAGO,&#10;                COLUMN_NOTIFICATION_PROFILE,&#10;                COLUMN_NOTIFICATION_IS_READ&#10;            ),&#10;            selection,&#10;            selectionArgs,&#10;            null,&#10;            null,&#10;            &quot;$COLUMN_NOTIFICATION_ID DESC&quot;&#10;        )&#10;&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_ID))&#10;                val actor = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_ACTOR))&#10;                val action = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_ACTION))&#10;                val location = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_LOCATION))&#10;                val timeAgo = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_TIMEAGO))&#10;                val profile = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_PROFILE))&#10;&#10;                val uiNotif = UINotification(&#10;                    id = id,&#10;                    userName = actor ?: &quot;&quot;,&#10;                    action = action ?: &quot;&quot;,&#10;                    location = location ?: &quot;&quot;,&#10;                    timeAgo = timeAgo ?: &quot;&quot;,&#10;                    profileImageUrl = profile&#10;                )&#10;&#10;                notifications.add(uiNotif)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return notifications&#10;    }&#10;&#10;    // Créer une notification&#10;    fun createNotification(recipientUserId: Int, actorName: String, actionText: String, location: String?, profileImageUrl: String?): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_NOTIFICATION_RECIPIENT, recipientUserId)&#10;            put(COLUMN_NOTIFICATION_ACTOR, actorName)&#10;            put(COLUMN_NOTIFICATION_ACTION, actionText)&#10;            put(COLUMN_NOTIFICATION_LOCATION, location)&#10;            put(COLUMN_NOTIFICATION_TIMEAGO, &quot;à l'instant&quot;)&#10;            put(COLUMN_NOTIFICATION_PROFILE, profileImageUrl)&#10;            put(COLUMN_NOTIFICATION_IS_READ, 0)&#10;        }&#10;        return db.insert(TABLE_NOTIFICATIONS, null, values)&#10;    }&#10;&#10;    // Marquer comme lu&#10;    fun markNotificationAsRead(notificationId: Int): Int {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_NOTIFICATION_IS_READ, 1)&#10;        }&#10;        return db.update(TABLE_NOTIFICATIONS, values, &quot;$COLUMN_NOTIFICATION_ID = ?&quot;, arrayOf(notificationId.toString()))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.checknshare.database&#10;&#10;import android.content.ContentValues&#10;import android.content.Context&#10;import android.database.sqlite.SQLiteDatabase&#10;import android.database.sqlite.SQLiteOpenHelper&#10;import android.util.Log&#10;import com.example.checknshare.models.Post&#10;import com.example.checknshare.ui.notifications.Notification as UINotification&#10;import java.security.MessageDigest&#10;import java.time.LocalDateTime&#10;import java.time.format.DateTimeFormatter&#10;&#10;class LocalDatabaseHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;LocalDatabaseHelper&quot;&#10;        private const val DATABASE_NAME = &quot;checknshare.db&quot;&#10;        // Version bumpée pour forcer onUpgrade et recréation de la DB avec les bons hashs&#10;        private const val DATABASE_VERSION = 3&#10;&#10;        // Users&#10;        private const val TABLE_USERS = &quot;users&quot;&#10;        private const val COLUMN_ID = &quot;id&quot;&#10;        private const val COLUMN_USERNAME = &quot;username&quot;&#10;        private const val COLUMN_EMAIL = &quot;email&quot;&#10;        private const val COLUMN_PASSWORD = &quot;password&quot;&#10;        private const val COLUMN_CREATED_AT = &quot;created_at&quot;&#10;&#10;        // Posts&#10;        private const val TABLE_POSTS = &quot;posts&quot;&#10;        private const val COLUMN_POST_ID = &quot;id&quot;&#10;        private const val COLUMN_POST_USER_ID = &quot;userId&quot;&#10;        private const val COLUMN_POST_IMAGE = &quot;imageName&quot;&#10;        private const val COLUMN_POST_LOCATION = &quot;location&quot;&#10;        private const val COLUMN_POST_LOCATION_ADDRESS = &quot;location_address&quot;&#10;        private const val COLUMN_POST_CREATED_AT = &quot;created_at&quot;&#10;&#10;        // Likes&#10;        private const val TABLE_LIKES = &quot;likes&quot;&#10;        private const val COLUMN_LIKE_ID = &quot;id&quot;&#10;        private const val COLUMN_LIKE_POST_ID = &quot;post_id&quot;&#10;        private const val COLUMN_LIKE_USER_ID = &quot;user_id&quot;&#10;&#10;        // Notifications&#10;        private const val TABLE_NOTIFICATIONS = &quot;notifications&quot;&#10;        private const val COLUMN_NOTIFICATION_ID = &quot;id&quot;&#10;        private const val COLUMN_NOTIFICATION_RECIPIENT = &quot;recipient_user_id&quot;&#10;        private const val COLUMN_NOTIFICATION_ACTOR = &quot;actor_name&quot;&#10;        private const val COLUMN_NOTIFICATION_ACTION = &quot;action_text&quot;&#10;        private const val COLUMN_NOTIFICATION_LOCATION = &quot;location&quot;&#10;        private const val COLUMN_NOTIFICATION_TIMEAGO = &quot;time_ago&quot;&#10;        private const val COLUMN_NOTIFICATION_PROFILE = &quot;profile_image&quot;&#10;        private const val COLUMN_NOTIFICATION_IS_READ = &quot;is_read&quot;&#10;    }&#10;&#10;    override fun onCreate(db: SQLiteDatabase?) {&#10;        Log.d(TAG, &quot;onCreate: creating tables if not exists&quot;)&#10;        // Users table&#10;        val createUsers = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_USERS (&#10;                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_USERNAME TEXT UNIQUE NOT NULL,&#10;                $COLUMN_EMAIL TEXT UNIQUE NOT NULL,&#10;                $COLUMN_PASSWORD TEXT NOT NULL,&#10;                $COLUMN_CREATED_AT TEXT DEFAULT CURRENT_TIMESTAMP&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        // Posts table&#10;        val createPosts = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_POSTS (&#10;                $COLUMN_POST_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_POST_USER_ID INTEGER NOT NULL,&#10;                $COLUMN_POST_IMAGE TEXT,&#10;                $COLUMN_POST_LOCATION TEXT,&#10;                $COLUMN_POST_LOCATION_ADDRESS TEXT,&#10;                $COLUMN_POST_CREATED_AT TEXT DEFAULT CURRENT_TIMESTAMP,&#10;                FOREIGN KEY($COLUMN_POST_USER_ID) REFERENCES $TABLE_USERS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        // Likes table&#10;        val createLikes = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_LIKES (&#10;                $COLUMN_LIKE_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_LIKE_POST_ID INTEGER NOT NULL,&#10;                $COLUMN_LIKE_USER_ID INTEGER NOT NULL,&#10;                FOREIGN KEY($COLUMN_LIKE_POST_ID) REFERENCES $TABLE_POSTS($COLUMN_POST_ID),&#10;                FOREIGN KEY($COLUMN_LIKE_USER_ID) REFERENCES $TABLE_USERS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        db?.execSQL(createUsers)&#10;        db?.execSQL(createPosts)&#10;        db?.execSQL(createLikes)&#10;&#10;        // Seed: créer un utilisateur de test&#10;        val hashedPassword = hashPassword(&quot;test123&quot;)&#10;        val userValues = ContentValues().apply {&#10;            put(COLUMN_USERNAME, &quot;test&quot;)&#10;            put(COLUMN_EMAIL, &quot;test@example.com&quot;)&#10;            put(COLUMN_PASSWORD, hashedPassword)&#10;        }&#10;        val userId = db?.insert(TABLE_USERS, null, userValues) ?: -1L&#10;&#10;        // Seed: quelques posts exemples (utiliser des drawables existants)&#10;        val sampleImages = listOf(&quot;photo_placeholder_1&quot;, &quot;photo_placeholder_2&quot;, &quot;photo_placeholder_3&quot;)&#10;        for (i in 0 until 3) {&#10;            val postValues = ContentValues().apply {&#10;                put(COLUMN_POST_USER_ID, userId.toInt())&#10;                put(COLUMN_POST_IMAGE, sampleImages[i % sampleImages.size])&#10;                put(COLUMN_POST_LOCATION, &quot;Paris, France&quot;)&#10;                put(COLUMN_POST_LOCATION_ADDRESS, &quot;Adresse Exemple $i&quot;)&#10;            }&#10;            val postId = db?.insert(TABLE_POSTS, null, postValues) ?: -1L&#10;&#10;            // Seed: ajouter quelques likes sur les posts&#10;            val likeCount = (i + 1) * 5&#10;            for (j in 0 until likeCount) {&#10;                val likeValues = ContentValues().apply {&#10;                    put(COLUMN_LIKE_POST_ID, postId.toInt())&#10;                    put(COLUMN_LIKE_USER_ID, userId.toInt())&#10;                }&#10;                db?.insert(TABLE_LIKES, null, likeValues)&#10;            }&#10;        }&#10;&#10;        // Notifications table (create and seed)&#10;        val createNotifications = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_NOTIFICATIONS (&#10;                $COLUMN_NOTIFICATION_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_NOTIFICATION_RECIPIENT INTEGER NOT NULL,&#10;                $COLUMN_NOTIFICATION_ACTOR TEXT,&#10;                $COLUMN_NOTIFICATION_ACTION TEXT,&#10;                $COLUMN_NOTIFICATION_LOCATION TEXT,&#10;                $COLUMN_NOTIFICATION_TIMEAGO TEXT,&#10;                $COLUMN_NOTIFICATION_PROFILE TEXT,&#10;                $COLUMN_NOTIFICATION_IS_READ INTEGER DEFAULT 0,&#10;                FOREIGN KEY($COLUMN_NOTIFICATION_RECIPIENT) REFERENCES $TABLE_USERS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;&#10;        db?.execSQL(createNotifications)&#10;&#10;        // Seed: créer quelques notifications d'exemple pour l'utilisateur test&#10;        val sampleNotifications = listOf(&#10;            UINotification(1, &quot;Marie Dubois&quot;, &quot;a publié une photo&quot;, &quot;Tour Eiffel, Paris&quot;, &quot;5 min&quot;),&#10;            UINotification(2, &quot;Alex Martin&quot;, &quot;a publié une photo&quot;, &quot;Le Comptoir du Relais, Paris&quot;, &quot;1h&quot;),&#10;            UINotification(3, &quot;Sophie Bernard&quot;, &quot;a commenté votre photo&quot;, &quot;Musée du Louvre, Paris&quot;, &quot;2h&quot;),&#10;            UINotification(4, &quot;Thomas Laurent&quot;, &quot;a aimé votre photo&quot;, &quot;Arc de Triomphe, Paris&quot;, &quot;3h&quot;)&#10;        )&#10;&#10;        for (n in sampleNotifications) {&#10;            val notifValues = ContentValues().apply {&#10;                put(COLUMN_NOTIFICATION_RECIPIENT, userId.toInt())&#10;                put(COLUMN_NOTIFICATION_ACTOR, n.userName)&#10;                put(COLUMN_NOTIFICATION_ACTION, n.action)&#10;                put(COLUMN_NOTIFICATION_LOCATION, n.location)&#10;                put(COLUMN_NOTIFICATION_TIMEAGO, n.timeAgo)&#10;                put(COLUMN_NOTIFICATION_PROFILE, n.profileImageUrl)&#10;            }&#10;            db?.insert(TABLE_NOTIFICATIONS, null, notifValues)&#10;        }&#10;    }&#10;&#10;    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {&#10;        Log.d(TAG, &quot;onUpgrade: upgrading DB from $oldVersion to $newVersion - dropping and recreating tables (dev)&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_LIKES&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_POSTS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_USERS&quot;)&#10;        db?.execSQL(&quot;DROP TABLE IF EXISTS $TABLE_NOTIFICATIONS&quot;)&#10;        onCreate(db)&#10;    }&#10;&#10;    override fun onOpen(db: SQLiteDatabase?) {&#10;        super.onOpen(db)&#10;        Log.d(TAG, &quot;onOpen: ensuring posts table exists&quot;)&#10;        // Create posts table if it's missing (safe no-op if already present)&#10;        val ensurePosts = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS $TABLE_POSTS (&#10;                $COLUMN_POST_ID INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                $COLUMN_POST_USER_ID INTEGER NOT NULL,&#10;                $COLUMN_POST_IMAGE TEXT,&#10;                $COLUMN_POST_LOCATION TEXT,&#10;                $COLUMN_POST_LOCATION_ADDRESS TEXT,&#10;                $COLUMN_POST_CREATED_AT TEXT DEFAULT CURRENT_TIMESTAMP,&#10;                FOREIGN KEY($COLUMN_POST_USER_ID) REFERENCES $TABLE_USERS($COLUMN_ID)&#10;            )&#10;        &quot;&quot;&quot;.trimIndent()&#10;        db?.execSQL(ensurePosts)&#10;    }&#10;&#10;    private fun hashPassword(password: String): String {&#10;        val bytes = MessageDigest.getInstance(&quot;SHA-256&quot;).digest(password.toByteArray())&#10;        return bytes.joinToString(&quot;&quot;) { &quot;%02x&quot;.format(it) }&#10;    }&#10;&#10;    // Authentifier un utilisateur par username&#10;    fun authenticateUser(username: String, password: String): User? {&#10;        val db = readableDatabase&#10;        val hashedPassword = hashPassword(password)&#10;&#10;        Log.d(TAG, &quot;authenticateUser: Attempting to authenticate user: $username&quot;)&#10;        Log.d(TAG, &quot;authenticateUser: Hashed password: $hashedPassword&quot;)&#10;&#10;        // D'abord vérifier si l'utilisateur existe&#10;        val userCheckCursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID, COLUMN_USERNAME, COLUMN_EMAIL, COLUMN_PASSWORD),&#10;            &quot;$COLUMN_USERNAME = ?&quot;,&#10;            arrayOf(username),&#10;            null, null, null&#10;        )&#10;&#10;        if (userCheckCursor.moveToFirst()) {&#10;            val storedPassword = userCheckCursor.getString(userCheckCursor.getColumnIndexOrThrow(COLUMN_PASSWORD))&#10;            Log.d(TAG, &quot;authenticateUser: User found. Stored password hash: $storedPassword&quot;)&#10;            Log.d(TAG, &quot;authenticateUser: Password match: ${storedPassword == hashedPassword}&quot;)&#10;            userCheckCursor.close()&#10;        } else {&#10;            Log.d(TAG, &quot;authenticateUser: User not found in database&quot;)&#10;            userCheckCursor.close()&#10;            return null&#10;        }&#10;&#10;        // Authentification avec mot de passe&#10;        val cursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID, COLUMN_USERNAME, COLUMN_EMAIL),&#10;            &quot;$COLUMN_USERNAME = ? AND $COLUMN_PASSWORD = ?&quot;,&#10;            arrayOf(username, hashedPassword),&#10;            null, null, null&#10;        )&#10;&#10;        return if (cursor.moveToFirst()) {&#10;            val user = User(&#10;                id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID)),&#10;                username = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_USERNAME)),&#10;                email = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_EMAIL))&#10;            )&#10;            cursor.close()&#10;            Log.d(TAG, &quot;authenticateUser: Authentication successful for user: $username&quot;)&#10;            user&#10;        } else {&#10;            cursor.close()&#10;            Log.d(TAG, &quot;authenticateUser: Authentication failed - password mismatch&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    // Authentifier un utilisateur par email&#10;    fun authenticateUserByEmail(email: String, password: String): User? {&#10;        val db = readableDatabase&#10;        val hashedPassword = hashPassword(password)&#10;&#10;        Log.d(TAG, &quot;authenticateUserByEmail: Attempting to authenticate user with email: $email&quot;)&#10;        Log.d(TAG, &quot;authenticateUserByEmail: Hashed password: $hashedPassword&quot;)&#10;&#10;        // D'abord vérifier si l'utilisateur existe&#10;        val userCheckCursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID, COLUMN_USERNAME, COLUMN_EMAIL, COLUMN_PASSWORD),&#10;            &quot;$COLUMN_EMAIL = ?&quot;,&#10;            arrayOf(email),&#10;            null, null, null&#10;        )&#10;&#10;        if (userCheckCursor.moveToFirst()) {&#10;            val storedPassword = userCheckCursor.getString(userCheckCursor.getColumnIndexOrThrow(COLUMN_PASSWORD))&#10;            Log.d(TAG, &quot;authenticateUserByEmail: User found. Stored password hash: $storedPassword&quot;)&#10;            Log.d(TAG, &quot;authenticateUserByEmail: Password match: ${storedPassword == hashedPassword}&quot;)&#10;            userCheckCursor.close()&#10;        } else {&#10;            Log.d(TAG, &quot;authenticateUserByEmail: User not found in database&quot;)&#10;            userCheckCursor.close()&#10;            return null&#10;        }&#10;&#10;        // Authentification avec mot de passe&#10;        val cursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID, COLUMN_USERNAME, COLUMN_EMAIL),&#10;            &quot;$COLUMN_EMAIL = ? AND $COLUMN_PASSWORD = ?&quot;,&#10;            arrayOf(email, hashedPassword),&#10;            null, null, null&#10;        )&#10;&#10;        return if (cursor.moveToFirst()) {&#10;            val user = User(&#10;                id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID)),&#10;                username = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_USERNAME)),&#10;                email = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_EMAIL))&#10;            )&#10;            cursor.close()&#10;            Log.d(TAG, &quot;authenticateUserByEmail: Authentication successful for email: $email&quot;)&#10;            user&#10;        } else {&#10;            cursor.close()&#10;            Log.d(TAG, &quot;authenticateUserByEmail: Authentication failed - password mismatch&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    // Créer un nouvel utilisateur (retourne true/false)&#10;    fun createUser(username: String, email: String, password: String): Boolean {&#10;        val db = writableDatabase&#10;        val hashedPassword = hashPassword(password)&#10;&#10;        Log.d(TAG, &quot;createUser: Creating user: $username with email: $email&quot;)&#10;        Log.d(TAG, &quot;createUser: Hashed password: $hashedPassword&quot;)&#10;&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_USERNAME, username)&#10;            put(COLUMN_EMAIL, email)&#10;            put(COLUMN_PASSWORD, hashedPassword)&#10;        }&#10;&#10;        return try {&#10;            val result = db.insert(TABLE_USERS, null, values)&#10;            if (result != -1L) {&#10;                Log.d(TAG, &quot;createUser: User created successfully with ID: $result&quot;)&#10;                true&#10;            } else {&#10;                Log.e(TAG, &quot;createUser: Failed to insert user&quot;)&#10;                false&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;createUser: Exception occurred: ${e.message}&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Créer un nouvel utilisateur et retourner l'id inséré (ou -1 si erreur)&#10;    fun createUserReturnId(username: String, email: String, password: String): Long {&#10;        val db = writableDatabase&#10;        val hashedPassword = hashPassword(password)&#10;&#10;        Log.d(TAG, &quot;createUserReturnId: Creating user: $username with email: $email&quot;)&#10;        Log.d(TAG, &quot;createUserReturnId: Hashed password: $hashedPassword&quot;)&#10;&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_USERNAME, username)&#10;            put(COLUMN_EMAIL, email)&#10;            put(COLUMN_PASSWORD, hashedPassword)&#10;        }&#10;        return try {&#10;            val result = db.insert(TABLE_USERS, null, values)&#10;            Log.d(TAG, &quot;createUserReturnId: User created with ID: $result&quot;)&#10;            result&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;createUserReturnId: Exception occurred: ${e.message}&quot;, e)&#10;            -1L&#10;        }&#10;    }&#10;&#10;    // Vérifier si un utilisateur existe&#10;    fun userExists(username: String): Boolean {&#10;        val db = readableDatabase&#10;        val cursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID),&#10;            &quot;$COLUMN_USERNAME = ?&quot;,&#10;            arrayOf(username),&#10;            null, null, null&#10;        )&#10;&#10;        val exists = cursor.count &gt; 0&#10;        cursor.close()&#10;        return exists&#10;    }&#10;&#10;    // Récupérer tous les posts (avec username)&#10;    fun getAllPosts(): List&lt;Post&gt; {&#10;        val posts = mutableListOf&lt;Post&gt;()&#10;        val db = readableDatabase&#10;        val query = &quot;SELECT p.$COLUMN_POST_ID as id, p.$COLUMN_POST_USER_ID as user_id, u.$COLUMN_USERNAME as username, p.$COLUMN_POST_IMAGE as image_name, p.$COLUMN_POST_LOCATION as location, p.$COLUMN_POST_LOCATION as location_address, p.$COLUMN_POST_CREATED_AT as created_at FROM $TABLE_POSTS p JOIN $TABLE_USERS u ON p.$COLUMN_POST_USER_ID = u.$COLUMN_ID ORDER BY p.$COLUMN_POST_CREATED_AT DESC&quot;&#10;        val cursor = db.rawQuery(query, null)&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val post = Post(&#10;                    id = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;id&quot;)),&#10;                    userId = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;user_id&quot;)),&#10;                    username = cursor.getString(cursor.getColumnIndexOrThrow(&quot;username&quot;)),&#10;                    imageName = cursor.getString(cursor.getColumnIndexOrThrow(&quot;image_name&quot;)),&#10;                    location = cursor.getString(cursor.getColumnIndexOrThrow(&quot;location&quot;)),&#10;                    locationAddress = cursor.getString(cursor.getColumnIndexOrThrow(&quot;location_address&quot;)),&#10;                    createdAt = cursor.getString(cursor.getColumnIndexOrThrow(&quot;created_at&quot;))&#10;                )&#10;                posts.add(post)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        Log.d(TAG, &quot;getAllPosts: retrieved ${posts.size} posts&quot;);&#10;        return posts&#10;    }&#10;&#10;    // Obtenir le nombre de likes pour un post&#10;    fun getLikeCount(postId: Int): Int {&#10;        val db = readableDatabase&#10;        val cursor = db.query(&#10;            TABLE_LIKES,&#10;            arrayOf(&quot;COUNT(*) as cnt&quot;),&#10;            &quot;$COLUMN_LIKE_POST_ID = ?&quot;,&#10;            arrayOf(postId.toString()),&#10;            null, null, null&#10;        )&#10;        var count = 0&#10;        if (cursor.moveToFirst()) {&#10;            count = cursor.getInt(cursor.getColumnIndexOrThrow(&quot;cnt&quot;))&#10;        }&#10;        cursor.close()&#10;        return count&#10;    }&#10;&#10;    // Créer un post&#10;    fun createPost(userId: Int, imageName: String?, location: String?): Long {&#10;        val db = writableDatabase&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;dd-MM-yyy HH:mm&quot;)&#10;        val currentDate = LocalDateTime.now().format(formatter)&#10;&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_POST_USER_ID, userId)&#10;            put(COLUMN_POST_IMAGE, imageName)&#10;            put(COLUMN_POST_LOCATION, location)&#10;            put(COLUMN_POST_LOCATION_ADDRESS, location)&#10;            put(COLUMN_POST_CREATED_AT, currentDate)&#10;        }&#10;        return db.insert(TABLE_POSTS, null, values)&#10;    }&#10;&#10;    // Supprimer un post (et ses likes associés en cascade grâce aux FK)&#10;    fun deletePost(postId: Int): Int {&#10;        val db = writableDatabase&#10;        // Supprimer d'abord les likes associés&#10;        db.delete(TABLE_LIKES, &quot;$COLUMN_LIKE_POST_ID = ?&quot;, arrayOf(postId.toString()))&#10;        // Puis supprimer le post&#10;        return db.delete(TABLE_POSTS, &quot;$COLUMN_POST_ID = ?&quot;, arrayOf(postId.toString()))&#10;    }&#10;&#10;    // Vérifier si un utilisateur a liké un post&#10;    fun hasUserLiked(postId: Int, userId: Int): Boolean {&#10;        val db = readableDatabase&#10;        val cursor = db.query(&#10;            TABLE_LIKES,&#10;            arrayOf(COLUMN_LIKE_ID),&#10;            &quot;$COLUMN_LIKE_POST_ID = ? AND $COLUMN_LIKE_USER_ID = ?&quot;,&#10;            arrayOf(postId.toString(), userId.toString()),&#10;            null, null, null&#10;        )&#10;        val liked = cursor.count &gt; 0&#10;        cursor.close()&#10;        return liked&#10;    }&#10;&#10;    // Ajouter un like&#10;    fun addLike(postId: Int, userId: Int): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_LIKE_POST_ID, postId)&#10;            put(COLUMN_LIKE_USER_ID, userId)&#10;        }&#10;        return db.insert(TABLE_LIKES, null, values)&#10;    }&#10;&#10;    // Retirer un like&#10;    fun removeLike(postId: Int, userId: Int): Int {&#10;        val db = writableDatabase&#10;        return db.delete(&#10;            TABLE_LIKES,&#10;            &quot;$COLUMN_LIKE_POST_ID = ? AND $COLUMN_LIKE_USER_ID = ?&quot;,&#10;            arrayOf(postId.toString(), userId.toString())&#10;        )&#10;    }&#10;&#10;    // Basculer like/unlike, retourne true si maintenant liké&#10;    fun toggleLike(postId: Int, userId: Int): Boolean {&#10;        if (hasUserLiked(postId, userId)) {&#10;            removeLike(postId, userId)&#10;            return false&#10;        }&#10;        addLike(postId, userId)&#10;        return true&#10;    }&#10;&#10;    // Obtenir un any user id existant (utile pour dev bypass)&#10;    fun getAnyUserId(): Int {&#10;        val db = readableDatabase&#10;        val cursor = db.query(&#10;            TABLE_USERS,&#10;            arrayOf(COLUMN_ID),&#10;            null, null, null, null, &quot;$COLUMN_ID ASC&quot;,&#10;            &quot;1&quot;&#10;        )&#10;        var id = -1&#10;        if (cursor.moveToFirst()) {&#10;            id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID))&#10;        }&#10;        cursor.close()&#10;        return id&#10;    }&#10;&#10;    // Récupérer toutes les notifications pour un utilisateur (par défaut tous)&#10;    fun getAllNotifications(recipientUserId: Int? = null): List&lt;UINotification&gt; {&#10;        val notifications = mutableListOf&lt;UINotification&gt;()&#10;        val db = readableDatabase&#10;        val selection: String?&#10;        val selectionArgs: Array&lt;String&gt;?&#10;        if (recipientUserId != null) {&#10;            selection = &quot;$COLUMN_NOTIFICATION_RECIPIENT = ?&quot;&#10;            selectionArgs = arrayOf(recipientUserId.toString())&#10;        } else {&#10;            selection = null&#10;            selectionArgs = null&#10;        }&#10;&#10;        val cursor = db.query(&#10;            TABLE_NOTIFICATIONS,&#10;            arrayOf(&#10;                COLUMN_NOTIFICATION_ID,&#10;                COLUMN_NOTIFICATION_ACTOR,&#10;                COLUMN_NOTIFICATION_ACTION,&#10;                COLUMN_NOTIFICATION_LOCATION,&#10;                COLUMN_NOTIFICATION_TIMEAGO,&#10;                COLUMN_NOTIFICATION_PROFILE,&#10;                COLUMN_NOTIFICATION_IS_READ&#10;            ),&#10;            selection,&#10;            selectionArgs,&#10;            null,&#10;            null,&#10;            &quot;$COLUMN_NOTIFICATION_ID DESC&quot;&#10;        )&#10;&#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                val id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_ID))&#10;                val actor = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_ACTOR))&#10;                val action = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_ACTION))&#10;                val location = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_LOCATION))&#10;                val timeAgo = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_TIMEAGO))&#10;                val profile = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTIFICATION_PROFILE))&#10;&#10;                val uiNotif = UINotification(&#10;                    id = id,&#10;                    userName = actor ?: &quot;&quot;,&#10;                    action = action ?: &quot;&quot;,&#10;                    location = location ?: &quot;&quot;,&#10;                    timeAgo = timeAgo ?: &quot;&quot;,&#10;                    profileImageUrl = profile&#10;                )&#10;&#10;                notifications.add(uiNotif)&#10;            } while (cursor.moveToNext())&#10;        }&#10;        cursor.close()&#10;        return notifications&#10;    }&#10;&#10;    // Créer une notification&#10;    fun createNotification(recipientUserId: Int, actorName: String, actionText: String, location: String?, profileImageUrl: String?): Long {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_NOTIFICATION_RECIPIENT, recipientUserId)&#10;            put(COLUMN_NOTIFICATION_ACTOR, actorName)&#10;            put(COLUMN_NOTIFICATION_ACTION, actionText)&#10;            put(COLUMN_NOTIFICATION_LOCATION, location)&#10;            put(COLUMN_NOTIFICATION_TIMEAGO, &quot;à l'instant&quot;)&#10;            put(COLUMN_NOTIFICATION_PROFILE, profileImageUrl)&#10;            put(COLUMN_NOTIFICATION_IS_READ, 0)&#10;        }&#10;        return db.insert(TABLE_NOTIFICATIONS, null, values)&#10;    }&#10;&#10;    // Marquer comme lu&#10;    fun markNotificationAsRead(notificationId: Int): Int {&#10;        val db = writableDatabase&#10;        val values = ContentValues().apply {&#10;            put(COLUMN_NOTIFICATION_IS_READ, 1)&#10;        }&#10;        return db.update(TABLE_NOTIFICATIONS, values, &quot;$COLUMN_NOTIFICATION_ID = ?&quot;, arrayOf(notificationId.toString()))&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle/wrapper/gradle-wrapper.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle/wrapper/gradle-wrapper.properties" />
              <option name="originalContent" value="#Tue Oct 07 16:26:02 CEST 2025&#10;distributionBase=GRADLE_USER_HOME&#10;distributionPath=wrapper/dists&#10;distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip&#10;zipStoreBase=GRADLE_USER_HOME&#10;zipStorePath=wrapper/dists&#10;" />
              <option name="updatedContent" value="#Tue Oct 07 16:26:02 CEST 2025&#10;distributionBase=GRADLE_USER_HOME&#10;distributionPath=wrapper/dists&#10;distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip&#10;zipStoreBase=GRADLE_USER_HOME&#10;zipStorePath=wrapper/dists&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>